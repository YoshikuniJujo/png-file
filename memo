2013.04.11 Thu.

data PNGParams = PNGParams {
	pngWidth :: Int,
	pngHeight :: Int,
	pngColorDepth :: Int,
	pngHasAlpha :: Bool,
	pngHasColor :: Bool,
	pngHasPallet :: Bool
 }

後々の拡張のため、PNGParams は公開しない。
setPNGWidth ... と pngWidth ... とを公開することにする。
つまり、setter と getter だ。

class PNGImage pi where
	type PNGColor pi
	type PNGColors pi
	bsToPNGImage :: PNGParams -> Lazy.ByteString -> pi
	pngImageToBs :: pi -> Lazy.ByteString
	setPixel :: Int -> Int -> pi -> pi
	getPixel :: Int -> Int -> pi -> PNGColor pi
	colorsToPNGImage :: PNGParams -> PNGColors pi -> pi
	pngImageToColors :: pi -> PNGColors

2013.04.12 Fri.

とりあえず、読み込み、書き込みの際の CRC の自動チェック、自動変換はできるようにした。
しかし、ChunkBody が二重化されてしまっているのがあまり美しくないな

上記は一応解決した。ただ、fromBinary と toBinary を同時に行っているところがあるけど。
まあ、そこはとりあえずはいいとする。

で、どんなふうにするかを昨日考えたわけだが、
読み込んだ PNG data から変換していくこととした。

最終的な形としては、

PNGParams { width, height, etc, Maybe pallet, Maybe etc } というものを作る。
また、class PNGImage を作りいくつかの method を追加する。
IDAT より先に来る chunk の内容は PNGParams にまとめることとして、
それ以外の Chunk は正式なものはそれぞれのスロットに入れ、
そうでないものは others にまとめて ByteString の形で入れておこうかな。
ここらへんを、もっと柔軟に、たとえば String も使えるようにする、
とかもいいかもしれない。

class Field pi => PNGImage pi where
	type PNGColor pi
	setPixel :: pi -> Int -> Int -> PNGColor pi -> pi
	getPixel :: pi -> Int -> Int -> PNGColor pi
	constructPNGImage :: pi -> PNGColor pi -> pi

こんな感じかな。
で、ByteString と [] を使った data をこれの instance としておこう。

2013.04.13 Sat.

Other chunk はその field に name が必要だ。

2013.04.14 Sun.

名前とデータ構造を結びつける必要がある。
[("IHDR", ChunkIHDR), ("gAMA", ChunkGAMA) ... ] 等が必要だ。
逆もできなければならないわけだがそれはすこし難しいかな。
もしかすると、T_IHDR 等は無駄かもしれない。
何となくきれいな感じがするのだけど、
別に String または ByteString で型を決めたっていいわけだし ...

T_IHDR 等は使えるかもしれない。
T_IHDR -> ChunkIHDR 等を自動生成してしまえば良いのでは。
そうすれば、あとは
[(T_IHDR, "IHDR"), (T_GAMA, "gAMA") ... ] を作っておけば良い。
chunkMaker T_IHDR ... のように使えるだろう。

T_IHDR -> ChunkIHDR の自動生成は上手くいかない。
つまり、各コンストラクターの型が違うということだ。
コード生成を使うしかないのだろうか。

2013.04.15 Mon.

自動生成等はうまくいった。
そしてコードの重複はかなり消せたが、コードはぐちゃぐちゃになった。
refactoring が必要だ。
それぞれの module の in と out についてちゃんと考える必要がある。
まずは今のままの名前で働きをきちんと特定して、
そのあとで適切な名前を与えよう。

File.Binary.PNG.RW を refactoring 中だ。
この module は何をするべきか。
上に対しては、Binary <-> [Chunk] をするべきだろう。
今のところはそこらへんがちゃんとしてない。
上に対して PNG(..) を公開するべきではないだろう。
typeChunk や TypeChunk は公開していいだろう。
これらはつまり Chunk を上手く扱うための構造なのだから。
needs, beforeIDATs, beforePLTEs, anyplaces は名前を変えよう。
これらはいずれかの形で必要にはなる。

createChunk と chunkData は上に公開するべきではないだろう。
IHDR, PLTE, IDAT, IEND 等はどう考えるべきか。
これらはおそらく必要になるだろう。

さて、細かい話は上のようになるだろうが、もっと大きい話のメモをしておこう。
つまり、Binary と [Chunk] の相互変換をする module が必要だ。
それが現在のところ File.Binary.PNG.RW あたりでやっていることだ。
そして真の意味での Chunks module は、IHDR 等を公開する。
これは別に import したほうが良さそうだ。
data Chunk はそれらの chunk 達をひとつにまとめるためだけにあるということを意識
しておく必要がある。

とりあえず Binary と [Chunk] の相互変換の部分だけ作るべきだろう。

今、RW.hs としているものを Chunks.hs とする。

2013.04.17 Wed.

fromBinary (n, "SOME") = fmap (first ChunkSOME) . fromBinary n
fromBinary (n, typ) = fmap (first (Others typ)) . fromBinary n

toBinary (n, _) (ChunkSOME dat) = toBinary n dat
toBinary (n, _) (Others _ dat) = toBinary n dat

上記の構造を作るのだが、できるだけ一般的な関数を作って、それを使いたい。

mkFromBinary で Others を特別扱いしないためにはどうすれば良いか。
mkToBinary で Others を特別扱いしないためには引数の数が多かったらそこを wildP
にするという実装でいいだろう。

2013.04.18 Thu.

nameToType "SOME" = T_SOME
nameToType typ = T_Others typ

typeToName T_SOME = "SOME"
typeToName (T_Others typ) = typ
